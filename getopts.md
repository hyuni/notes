# `getopts`

from [here](https://archive.is/TRzn4)

* parse command line arguments
* `POSIX` defined

## example
```shell
$ mybackup -x -f /etc/mybackup.conf -r ./foo.txt ./bar.txt
```

* `-x` is an option (aka flag or switch). It consists of a dash `-` followed by
one charact.
* `-f` is also an option, but this option has an associated option argument (an
argument to the option `-f`): `/etc/mybackup.conf`. The option argument is usually
the argument following the option itself, but that isn't mandatory. Joining
the option and option argument into a single argument `-f/etc/mybackup.conf` is
valid.
* `-r` depends on the configuration. In this example, `-r` doesn't take arguments
so it's a standalone option like `-x`.
* `./foo.txt` and `./bar.txt` are remaining arguments without any associated
options. These are often used as mass-arguments. For example, the filenames
specified for `cp(1)`, or arguments that don't need an option to be recognized
because of the intended behavior of the program. POSIX calls them operands.

## used variables

* `OPTIND`	Holds the index to the next argument to be processed. This is how getopts
"remembers" its own status between invocations. Also useful to shift the
positional parameters after processing with getopts. `OPTIND` is initially set to
1, and needs to be re-set to 1 if you want to parse anything again with getopts
* `OPTARG`	This variable is set to any argument for an option found by getopts. It
also contains the option flag of an unknown option. `OPTERR`	(Values 0 or 1)
Indicates if Bash should display error messages generated by the getopts
builtin. The value is initialized to 1 on every shell startup - so be sure to
always set it to 0 if you don't want to see annoying messages! `OPTERR` is not
specified by POSIX for the getopts builtin utility — only for the C `getopt()`
function in unistd.h (opterr).
* `OPTERR` is bash-specific and not supported by
shells such as ksh93, mksh, zsh, or dash.

## base-syntax

```shell
getopts OPTSTRING VARNAME [ARGS...]
```

where:
* `OPTSTRING`	tells `getopts` which options to expect and where to expect arguments (see below)
* `VARNAME`	tells `getopts` which shell-variable to use for option reporting
* `ARGS`	tells `getopts` to parse these optional words instead of the positional parameters

## the option-string

The option-string tells `getopts` which options to expect and which of them must
have an argument. The syntax is very simple — every option character is simply
named as is, this example-string would tell `getopts` to look for `-f`, `-A` and
`-x`:
```shell
getopts fAx VARNAME
```

When you want `getopts` to expect an argument for an option, just place a `:`
(colon) after the proper option flag. If you want `-A` to expect an argument (i.e.
to become `-A SOMETHING`) just do:

```shell
getopts fA:x VARNAME
```

### `getopt != getopts`

The external command `getopt(1)` is never safe to use, unless you know it is GNU
`getopt`, you call it in a GNU-specific way, and you ensure that `GETOPT_COMPATIBLE`
is not in the environment. Use `getopts` (shell builtin) instead, or simply loop
over the positional parameters

## `silent` and `verbose`
```shell
while getopts ":a" opt; do ... // silent mode, preceding :
while getopts "a" opt; do ... // verbose mode, no preceding :
```


### annotated example
from [here](https://stackoverflow.com/questions/16483119/example-of-how-to-use-getopts-in-bash)

```shell
usage() { echo "Usage: $0 [-s <45|90>] [-p <string>]" 1>&2; exit 1; }

// loop through the options
// note the colons after s and p indicate an expected named argument
while getopts ":s:p:" o; do // store the result into o
    case "${o}" in
        s)
            // OPTARG is set to any option argument, (like 45 or 90...)
            s=${OPTARG}
            // if not a valid value, exit
            ((s == 45 || s == 90)) || usage
            ;; // cases terminated with ;;
        p)
            // assign p
            p=${OPTARG}
            ;;
        *) // like the default statement
            usage
            ;;
    esac
done
// OPTIND is the index of the next argument to be processed
shift $((OPTIND-1)) // shift to the next argument till none left

// check if you got both vars you want
// if not, then bounce
if [ -z "${s}" ] || [ -z "${p}" ]; then
    usage
fi

echo "s = ${s}"
echo "p = ${p}"
```
